[
    {
        "problem": "String Compression",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/1322824085/",
        "code": "class Solution {\npublic:\n    int compress(vector<char>& chars) {\n        vector<char> c;\n        char fi = chars[0];\n        c.push_back(fi);\n        int co=1;\n        for(int i=1;i<chars.size();i++) {\n            if(fi == chars[i]) {\n                co++;\n            } else{\n                if(co > 1) {\n                    string count = to_string(co);\n                    for (char ch : count) {\n                        c.push_back(ch);\n                    }\n                }\n                co=1;\n                fi = chars[i];\n                c.push_back(fi);\n            }\n\n             if(i == chars.size() -1 && co > 1) {\n                string count = to_string(co);\n                for (char ch : count) {\n                    c.push_back(ch);\n                }\n             }\n        }\n        chars = c;\n        return chars.size();\n    }\n};"
    },
    {
        "problem": "Merge Sorted Array",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/1322215804/",
        "code": "class Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        for(size_t i=0 , j = m; i<nums2.size(); i++) {\n                nums1[j] = nums2[i];\n                 j++;\n        }\n        sort(nums1.begin(), nums1.end());\n    }\n};"
    },
    {
        "problem": "Longest Palindromic Substring",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/1321945607/",
        "code": "#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n        if (s.size() <= 1) return s;\n        \n        int maxLength = 1; \n        int start = 0;    \n        \n        for (int i = 0; i < s.size(); ++i) {\n            int left = i, right = i;\n            while (left >= 0 && right < s.size() && s[left] == s[right]) {\n                int currentLength = right - left + 1;\n                if (currentLength > maxLength) {\n                    maxLength = currentLength;\n                    start = left;\n                }\n                --left;\n                ++right;\n            }\n            \n            left = i, right = i + 1;\n            while (left >= 0 && right < s.size() && s[left] == s[right]) {\n                int currentLength = right - left + 1;\n                if (currentLength > maxLength) {\n                    maxLength = currentLength;\n                    start = left;\n                }\n                --left;\n                ++right;\n            }\n        }\n        \n        return s.substr(start, maxLength);\n    }\n};"
    },
    {
        "problem": "Increasing Triplet Subsequence",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/1321828440/",
        "code": "class Solution {\npublic:\n    bool increasingTriplet(vector<int>& nums) {\n         int n1 = INT_MAX;\n         int n2 = INT_MAX;\n         for(int i=0;i<nums.size();i++) {\n             if(nums[i] > n2) return true;\n             if(nums[i] <= n1) n1 = nums[i];\n             else if(nums[i] <= n2) n2 = nums[i];\n         }\n         return false;\n    }\n};"
    },
    {
        "problem": "Missing Number",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/1320834376/",
        "code": "class Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        map<int,bool> mp;\n        set<int> s;\n        for(size_t i=0;i<nums.size();i++) {\n            s.insert(nums[i]);\n        }\n\n        int t = s.size();\n        int max = *max_element(nums.begin(),nums.end());\n        if(max > t) t = max;\n\n        for(size_t i=0;i<=t;i++) {\n            mp.insert({i,false});\n        }\n\n        for(size_t i=0;i<nums.size();i++) {\n            mp[nums[i]] = true;\n        }\n\n        for(const auto & elm : mp) {\n            if(!elm.second) return elm.first;\n        }\n        return -1;\n    }\n};"
    },
    {
        "problem": "Merge Strings Alternately",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/1320060242/",
        "code": "class Solution {\npublic:\n    string mergeAlternately(string word1, string word2) {\n        int size = word1.size() > word2.size() ? word1.size() : word2.size();\n        string s = \"\";\n        for(int i=0;i<size;i++) {\n            if(i < word1.size()) s+=word1[i];\n            if(i < word2.size()) s+=word2[i];\n        }\n        return s;\n    } \n};"
    },
    {
        "problem": "Reverse Words in a String",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/1320018982/",
        "code": "class Solution {\npublic:\n    string reverseWords(string s) {\n        vector<string> st;\n        string f = \"\";\n        for(int i=0;i<s.size();i++) {\n            if(s[i] != ' ') {\n                f+=s[i];\n            } else {\n                    if(f != \"\") st.push_back(f);\n                    f = \"\";\n            }\n            if(i == s.size() - 1 && f != \"\") st.push_back(f);\n        }\n        int t = st.size() -1;\n        for(int i=0;i<st.size() / 2;i++){\n            string temp = st[i];\n            st[i] = st[t];\n            st[t] = temp;\n            t--;\n        }\n        f = \"\";\n        for(int i=0;i<st.size();i++){\n            if(i < st.size() - 1) f+=st[i]+' ';\n            else f+=st[i];\n        }\n        return f;\n    }\n};"
    },
    {
        "problem": "Reverse Vowels of a String",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/1319674147/",
        "code": "class Solution {\npublic:\n    string reverseVowels(string s) {\n        vector<int> v ;\n        for(int i=0;i<s.size();i++) {\n            if(tolower(s[i]) == 'e' || tolower(s[i])  == 'o' || tolower(s[i])  == 'a' \n                || tolower(s[i])  == 'i' ||tolower(s[i])  == 'u') {\n                v.push_back(i);\n            }\n        }\n\n        int t = v.size() - 1;\n        for(int i=0;i<v.size() / 2;i++) {\n            char temp = s[v[t]];\n            s[v[t]] = s[v[i]];\n            s[v[i]] = temp;\n            t--;\n        }\n         return s; \n    }\n};"
    },
    {
        "problem": "Can Place Flowers",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/1268585752/",
        "code": "class Solution {\npublic:\n    bool canPlaceFlowers(vector<int>& flowerbed, int n) {\n        int c = 0;\n        for (size_t i = 0; i < flowerbed.size(); i++) {\n            bool check1 = false;\n            bool check2 = false;\n            if (flowerbed[i] == 0) {\n                if (i + 1 < flowerbed.size()) {\n                    if (flowerbed[i + 1] == 0)\n                        check1 = true;\n                } else \n                    check1 = true;\n\n                if(i > 0) {\n                    if (flowerbed[i - 1] == 0) \n                        check2 = true;\n                } else check2 = true;\n                if (check1 && check2) {\n                    flowerbed[i] = 1;\n                    c++;\n                    if (c >= n) {\n                        return true; \n                    }\n                }\n            }\n        }\n        return c >= n;\n    }\n};"
    },
    {
        "problem": "Kids With the Greatest Number of Candies",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/1268542174/",
        "code": "class Solution {\npublic:\n    \n\n    vector<bool> kidsWithCandies(vector<int>& candies, int extraCandies) {\n        stack<int> maxes;\n        vector<bool> ar;  \n\n        int maxVal = *max_element(candies.begin(), candies.end());\n        for(size_t i = 0; i < candies.size(); i++) {\n            int s = candies[i] + extraCandies;\n            if(s >= maxVal)\n               ar.push_back(true);\n            else ar.push_back(false);\n        }\n        return ar;\n    }\n};"
    },
    {
        "problem": "Greatest Common Divisor of Strings",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/1268518020/",
        "code": "class Solution {\npublic:\n    int gcd(int a, int b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    bool isGood(string str,string x) {\n        int nbre = str.length() / x.length();\n        int co = 0;\n        for(int i=0;i<nbre;i++) {\n            string te = str.substr(co,x.length());\n            if(te != x)\n               return false;\n            co+=x.length();\n        }\n        return true;\n    }\n    string gcdOfStrings(string str1, string str2) {\n        int pgcd = gcd(str1.length(),str2.length());\n        string s = \"\";\n        for(int i=0;i<pgcd;i++) \n           s+=str1[i];\n        if(isGood(str1,s) && isGood(str2,s))\n            return s;\n        return \"\";\n    }\n};"
    },
    {
        "problem": "Longest Common Prefix",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/1211823752/",
        "code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n            if(strs.size() == 0) return \"\";\n            bool isPrefix = false;\n            string prefix = strs[0];\n            while(prefix.size() > 0) {\n                int count=0;\n                for(size_t i=1;i<strs.size();i++) {\n                    if(prefix == strs[i].substr(0,prefix.size()))\n                        count++;\n                }\n                if(count == strs.size()-1)\n                    break;\n                prefix = prefix.substr(0,prefix.size()-1);\n            }\n            return prefix;\n        }\n};"
    },
    {
        "problem": "Factorial Trailing Zeroes",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/1211731963/",
        "code": "class Solution:\n  \n\n    def trailingZeroes(self, n: int) -> int:\n        count = 0\n        while n >= 5:\n            n //= 5\n            count += n\n        return count"
    },
    {
        "problem": "Maximum Subarray",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/926587078/",
        "code": "class Solution {\n    public:\n        int maxSubArray(vector<int>& nums) {\n            int sum = 0;\n            int res = nums[0];\n            for(int i = 0;i<nums.size();i++)\n            {\n                sum+=nums[i];\n                if(nums[i] > sum)\n                    sum = nums[i];\n                res = max(sum,res);\n            }\n            return res;\n        }\n    };"
    },
    {
        "problem": "Count Servers that Communicate",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/925655728/",
        "code": "class Solution {\npublic:\n    int countServers(vector<vector<int>>& grid) {\n        int isola = 0;\n        int count = 0;\n        int all = 0;\n        int samLi = 0;\n        for(int i = 0;i<grid.size();i++)\n        {\n            for(int j = 0;j<grid[0].size();j++)\n            {\n                if(grid[i][j] == 1)\n                {\n                    all++;\n                    count = 0;\n                    samLi = 0;\n                    for(int z=0;z<grid.size();z++)\n                    {\n                        if(grid[z][j] == 1)\n                            count++;\n                    }\n                    for(int k = 0;k<grid[0].size();k++)\n                    {\n                        if(grid[i][k] == 1)\n                            samLi++;\n                    }\n                    if((count+samLi)-1 == 1)\n                        isola++;\n                }\n            }\n        }\n        return all-isola;\n    }\n};"
    },
    {
        "problem": "Sqrt(x)",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/925078074/",
        "code": "class Solution {\npublic:\n\n    int mySqrt(int x) {\n        long num = -1;\n        int right = 0;\n        int left = x;\n        //binary search : \n        while(right <= left)\n        {\n            long mid = (right + left) / 2;\n            if(mid * mid == x)\n                return (int)mid;\n            else if(mid *mid < x)\n            {\n                right = mid + 1;\n            } else \n            {\n                left = mid -1;\n            }\n        }\n        for(long i = 1;i<=x;i++)\n        {\n            if(i * i > x)\n            {\n                num = i-1;\n                break;\n            }\n        }\n        return (int)num;\n    }\n};"
    },
    {
        "problem": "Minimum Path Sum",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/925024527/",
        "code": "class Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n         for(int i = 1;i<n;i++)\n            grid[i][0] += grid[i-1][0];\n        for(int j = 1;j<m;j++)\n            grid[0][j] += grid[0][j-1];\n        for(int i = 1;i<n;i++)\n        {\n            for(int j = 1;j<m;j++)\n            {\n                grid[i][j] += min(grid[i-1][j],grid[i][j-1]);\n            }\n        }\n        return grid[n-1][m-1];\n    }\n};"
    },
    {
        "problem": "Remove Element",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/924469467/",
        "code": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int c = 0;\n        int taille = nums.size();\n        for(int i = 0;i<taille;i++)\n        {\n            if(nums[i] == val)\n            {\n                for(int j = i;j<taille-1;j++)\n                    nums[j] = nums[j+1];\n                taille--;\n                i--;\n            }\n        }\n        return taille;\n    }\n};"
    },
    {
        "problem": "Concatenation of Array",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/922492038/",
        "code": "class Solution {\npublic:\n    vector<int> getConcatenation(vector<int>& nums) {\n        vector<int> ans;\n        int i = 0;\n        int count = 0;\n        while(count < 2 * nums.size())\n        {\n             if(i == (nums.size())) \n                i = 0;\n            ans.push_back(nums[i]);\n            count ++;\n            i++;\n        }\n        return ans;\n    }\n};"
    },
    {
        "problem": "Build Array from Permutation",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/922488740/",
        "code": "class Solution {\npublic:\n    vector<int> buildArray(vector<int>& nums) {\n        vector<int> ans;\n        for(int i = 0;i<nums.size();i++)\n            ans.push_back(nums[nums[i]]);\n        return ans;\n    }\n};"
    },
    {
        "problem": "Two Sum",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/922209630/",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n            vector<int> numss;\n        for(int i = 0;i<nums.size();i++)\n        {\n            for(int j = i+1;j<nums.size();j++)\n            {\n                if(nums[i] + nums[j] == target)\n                {\n                    numss.push_back(i);\n                    numss.push_back(j);\n                    break;\n                }\n            }\n        }\n        return numss;\n    }\n};"
    },
    {
        "problem": "Remove Duplicates from Sorted Array",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/921871379/",
        "code": "class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int c =1;\n        //finding unique elements :\n        for(int i = 0;i<nums.size()-1;i++)\n        {\n            if(nums[i] != nums[i+1])\n            {\n                nums[c] = nums[i+1];\n                c++;\n            }\n        }\n        return c;\n    }\n};"
    },
    {
        "problem": "Median of Two Sorted Arrays",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/921870875/",
        "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        vector<int> mergeArray;\n        int j =0;\n        for(int i = 0;i<nums1.size();i++)\n            mergeArray.push_back(nums1[i]);\n        for(int i = 0;i<nums2.size();i++)\n            mergeArray.push_back(nums2[j++]);\n        sort(mergeArray.begin(),mergeArray.end());\n        if(mergeArray.size() % 2 == 0)\n        {\n            int l1 = mergeArray[(mergeArray.size()/2)-1];\n            int l2 = mergeArray[mergeArray.size()/2];\n            return (l1+l2)/2.0;\n        } else\n            return mergeArray[mergeArray.size()/2];\n    }\n};"
    },
    {
        "problem": "Merge Two Sorted Lists",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/921807949/",
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n \nclass Solution {\npublic:\n    void addNode(ListNode **head,int data)\n    {\n        ListNode *b = new ListNode;\n        b->val = data;\n        b->next = *head;\n        *head = b;\n    }\n\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n         ListNode *temp = list1;\n        ListNode *newList = NULL;\n        ListNode *temp2 = list2;\n        if(list1 != NULL && list2 != NULL)\n        {\n            while(temp != NULL)\n            {\n                addNode(&newList,temp->val);\n                temp = temp->next;\n            }\n            //merging the two list based in the last element : \n            temp = newList;\n            //getting last Node of the merged list :\n            while(temp->next != NULL)\n                temp = temp->next;\n            //connecting the last element with second list : \n            while(temp2 != NULL)\n            {\n                addNode(&temp->next,temp2->val);\n                temp2 = temp2->next;\n            }\n            //now sorting the list :\n            sortList(newList); \n        } else if(list1 == NULL) \n            return list2;\n          else return list1;\n        return newList;\n     }\n    void sortList(ListNode* list) \n    {\n        ListNode *temp = list;\n        ListNode *temp2 = NULL;\n        int buffer = 0;\n        while(temp != NULL)\n        {\n            temp2 = temp->next;\n            while(temp2 != NULL)\n            {\n                if(temp->val > temp2->val)\n                {\n                    buffer = temp2->val;\n                    temp2->val = temp->val;\n                    temp->val = buffer;\n                }\n                temp2 = temp2->next;\n            }\n            temp = temp->next;\n        }\n    }\n};"
    },
    {
        "problem": "Reverse Integer",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/921032292/",
        "code": "class Solution {\npublic:\n    int reverse(int x) {\n           int j = 0;\n            long sum = 0;\n            int siz;\n            vector<int> reverseInt;\n            while(x)\n            {\n                reverseInt.push_back(x%10);\n                x = x / 10;\n            }\n            siz = reverseInt.size()-1;\n            for(int i = 0;i<reverseInt.size();i++)\n            {\n                sum+=reverseInt[i] * pow(10,siz);\n                siz--;\n            }\n            if(sum > INT_MAX || sum < INT_MIN) return 0;\n            return (int)sum;\n    }\n};"
    },
    {
        "problem": "Roman to Integer",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/920948147/",
        "code": "class Solution {\npublic:\n    int romanToInt(string s) {\n            int sum = 0;\n            int i;\n            for( i=0;i<s.size();i++) {\n                if(s[i] == 'C' && s[i+1] == 'M') {\n                    sum+=900;\n                    i++;\n                    continue;\n                } else if(s[i] == 'C' && s[i+1]  == 'D') {\n                    sum+=400;\n                    i++;\n                    continue;\n                } else if(s[i]  == 'I' && s[i+1]  == 'V') {\n                    sum+=4;\n                    i++;\n                    continue;\n                } else if(s[i]  == 'I' && s[i+1] == 'X'){\n                    sum+=9;\n                    i++;\n                    continue;\n                } else if(s[i]  == 'X' && s[i+1]  == 'L') {\n                    sum+=40;\n                    i++;\n                    continue;\n                } else if(s[i] == 'X' && s[i+1]  == 'C') {\n                    sum+=90;\n                    i++;\n                    continue;\n                    }\n                switch(s[i] ) {\n                        case 'I': sum+=1;break;\n                        case 'V': sum+=5;break;\n                        case 'X': sum+=10;break;\n                        case 'L': sum+=50;break;\n                        case 'C': sum+=100;break;\n                        case 'D': sum+=500;break;\n                        case 'M': sum+=1000;break;\n                }\n            }\n            return sum;\n        }\n};"
    },
    {
        "problem": "Palindrome Number",
        "state": "Accepted",
        "url": "https://leetcode.com/submissions/detail/920391208/",
        "code": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n       vector<char> reverseString;\n       stringstream ss;\n       string str;\n       ss << x;\n       ss >> str;\n       for(int i = str.size()-1;i>=0;i--)\n           reverseString.push_back(str[i]);\n       for(int i = 0;i<str.size();i++)\n       {\n           if(str[i] != reverseString[i])\n             return false;\n       }\n       return true;\n    }\n};"
    }
]